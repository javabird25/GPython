"""
Provides the :class:`Entity` class which allows creating scripted entities (a.k.a. SENTs)
by the means of PyGmod.
"""

import os
from pathlib import Path
import atexit

from pygmod import addons
from pygmod.lua import MethodCallNamespace

__all__ = ["Entity"]

# Dictionary for keeping all Entity subclasses for accessing them from Lua.
# Keys are entity classnames
# *(not the __name__ of subclass, but the Source engine entity class name)*,
# values are subclasses.
entity_registry = {}


# pylint: disable=too-few-public-methods
class Entity:
    """Base class for scripted entities. To create a scripted entity, simply inherit this class.

    ::

        class MyEntity(Entity):
            def Initialize(self):
                ...
            ...

    Entity classname will be generated automatically and will look like
    ``MyAddon.python.__shared_autorun__.MyEntity``. You can set a custom classname by passing it
    as a keyword argument to the class inheritance parameters::

        class MyEntity(Entity, classname="attrs_myentity"):
            ...

    You can set the entity fields
    (described `here <http://wiki.garrysmod.com/page/Structures/ENT>`_)
    by setting the class-level attributes::

        class MyEntity(Entity):
            Type = "point"
            Category = "My Entities"
            PrintName = "My Entity"
            Author = "Me"
            ...

    By default, ``Base`` is set to ``"base_entity"`` and ``Type`` is set to ``"anim"``.
    Also, there is a default version of ``Draw()``, so you don't have to write it by yourself::

        def Draw(self, _):
            self._.DrawModel()

    .. note::

        To initialize your entity, you should use ``Initialize`` instead of ``__init__()``::

            class MyEnt(Entity):
                def Initialize(self):
                    print(f"Hello, world from entity #{self._.EntIndex()}")
    """

    Base = "base_entity"
    Type = "anim"

    def __init_subclass__(cls, classname=None):
        # Generate a classname if not specified
        if classname is None:
            classname = (cls.__module__ + "." + cls.__name__)

        generate_stub(cls, classname)
        entity_registry[classname] = cls

    def __init__(self):
        self._ = MethodCallNamespace(self)

    # pylint: disable=invalid-name
    def Draw(self, _):
        """Draws the entity's model by default."""
        self._.DrawModel()


def generate_stub(ent_cls, classname):
    """
    Generates a Lua source file ``<addon_path>/lua/entities/<classname>.lua``
    where entity attributes and methods are copied from ``ent_cls``.
    This file is required for Garry's Mod addon loader to detect the entity class.
    Also registers an ``atexit`` function which deletes the stub file on the game shutdown.
    """
    stub_file_path = create_stub_file(classname)

    with open(stub_file_path, "w+") as stub_file:
        stub_file.write(generate_stub_source(ent_cls, classname))

    atexit.register(remove_stub_file, stub_file_path)


def create_stub_file(classname):
    """
    Creates an empty file at path ``<addon_path>/lua/entities/<classname>.lua``
    and returns this path.
    """
    entity_stubs_path = Path(addons.current_addon_path, "lua", "entities")
    entity_stubs_path.mkdir(parents=True, exist_ok=True)
    return entity_stubs_path / Path(classname + ".lua")


def generate_stub_source(ent_cls, classname):
    """
    Generates the Lua source code for a file that is created in :func:`generate_stub`.
    The source code defines the entity class and its members.
    """

    src = f'-- This is a Lua stub for PyGmod entity "{classname}".\n' \
          "-- Do not edit this file, as it will be regenerated " \
          "upon the game/server restart.\n" \
          \
          "AddCSLuaFile()\n" \
          "local pygmod_entity = py.Import('pygmod.entity')\n"

    ent_class_dict = create_class_hierarchy_dict(ent_cls)
    for attr_name, attr_val in ent_class_dict.items():
        if callable(attr_val):  # Generate a function definition
            src += generate_stub_for_callable(attr_name, classname, ent_class_dict)
        else:  # Other types (numbers, strings, etc)
            src += f"ENT.{attr_name} = pygmod_entity.entity_registry" \
                   f".__getitem__({classname!r}).{attr_name}  -- {attr_val!r}\n"

    return src


def generate_stub_for_callable(attr_name, classname, ent_hierarchy_class_dict):
    """Generates the Lua source code for a function definition."""

    # This is a code template for static methods, class methods and regular functions.
    # The only difference is the arguments we pass to the callable.
    code = f"""
function ENT.{attr_name}(...)
    class = pygmod_entity.entity_registry.__getitem__({classname!r})
    callable = class.__getitem__({attr_name!r})
    return callable({{}})
end\n"""

    # Generating different code depending on the method type
    callable_ = ent_hierarchy_class_dict[attr_name]

    # Static method: no additional arguments required
    if isinstance(callable_, staticmethod):  # BUG: checks like this doesn't seem to work
        return code.format("...")

    # Class methods: the class as the first argument is required
    if isinstance(callable_, classmethod):
        return code.format("class, ...")

    # Regular method
    return code.format("self, ...")


def remove_stub_file(stub_path):
    """
    Removes ``stub_path`` and ignores :exc:`FileNotFoundError` if the ``stub_path`` file
    doesn't exist.
    """
    try:
        os.remove(stub_path)
    except FileNotFoundError:
        pass


def create_class_hierarchy_dict(cls):
    """Returns the dictionary with all members of the class ``cls`` and its superclasses."""
    dict_extension_order = cls.__mro__[-2::-1]  # Reversed __mro__ without the 'object' class
    attrs_dict = {}
    for base_class in dict_extension_order:
        attrs_dict.update(vars(base_class))
    return attrs_dict
